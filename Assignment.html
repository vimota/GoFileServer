<!DOCTYPE html>
<!-- saved from url=(0061)https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950 -->
<html dir="ltr" lang="en" xml:lang="en" class="yui3-js-enabled"><div id="yui3-css-stamp" style="position: absolute !important; visibility: hidden !important" class=""></div><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Enunciado</title>
    <link rel="shortcut icon" href="https://aulaglobal.uc3m.es/theme/image.php/fusionuc3m/theme/1412771764/favicon">
    
<meta name="keywords" content="moodle, Enunciado">
<link rel="stylesheet" type="text/css" href="./Assignment_files/yui_combo.php"><script type="text/javascript" src="./Assignment_files/yui_combo(1).php"></script><script id="firstthemesheet" type="text/css">/** Required in order to fix style inclusion problems in IE with YUI **/</script><link rel="stylesheet" type="text/css" href="./Assignment_files/all">
<script type="text/javascript">
//<![CDATA[
var M = {}; M.yui = {};
var moodleConfigFn = function(me) {var p = me.path, b = me.name.replace(/^moodle-/,'').split('-', 3), n = b.pop();if (/(skin|core)/.test(n)) {n = b.pop();me.type = 'css';};me.path = b.join('-')+'/'+n+'/'+n+'.'+me.type;};
var galleryConfigFn = function(me) {var p = me.path,v=M.yui.galleryversion,f;if(/-(skin|core)/.test(me.name)) {me.type = 'css';p = p.replace(/-(skin|core)/, '').replace(/\.js/, '.css').split('/'), f = p.pop().replace(/(\-(min|debug))/, '');if (/-skin/.test(me.name)) {p.splice(p.length,0,v,'assets','skins','sam', f);} else {p.splice(p.length,0,v,'assets', f);};} else {p = p.split('/'), f = p.pop();p.splice(p.length,0,v, f);};me.path = p.join('/');};
var yui2in3ConfigFn = function(me) {if(/-skin|reset|fonts|grids|base/.test(me.name)){me.type='css';me.path=me.path.replace(/\.js/,'.css');me.path=me.path.replace(/\/yui2-skin/,'/assets/skins/sam/yui2-skin');}};
YUI_config = {"base":"https:\/\/aulaglobal.uc3m.es\/lib\/yuilib\/3.7.3\/build\/","comboBase":"https:\/\/aulaglobal.uc3m.es\/theme\/yui_combo.php?","combine":true,"filter":"","insertBefore":"firstthemesheet","modules":{"core_filepicker":{"name":"core_filepicker","fullpath":"https:\/\/aulaglobal.uc3m.es\/lib\/javascript.php\/1412771762\/repository\/filepicker.js","requires":["base","node","node-event-simulate","json","async-queue","io-base","io-upload-iframe","io-form","yui2-treeview","panel","cookie","datatable","datatable-sort","resize-plugin","dd-plugin","escape","moodle-core_filepicker"]},"core_dock":{"name":"core_dock","fullpath":"https:\/\/aulaglobal.uc3m.es\/lib\/javascript.php\/1412771762\/blocks\/dock.js","requires":["base","node","event-custom","event-mouseenter","event-resize"]}},"groups":{"moodle":{"name":"moodle","base":"https:\/\/aulaglobal.uc3m.es\/theme\/yui_combo.php?moodle\/1412771762\/","comboBase":"https:\/\/aulaglobal.uc3m.es\/theme\/yui_combo.php?","combine":true,"filter":"","ext":false,"root":"moodle\/1412771762\/","patterns":{"moodle-":{"group":"moodle","configFn":moodleConfigFn}}},"local":{"name":"gallery","base":"https:\/\/aulaglobal.uc3m.es\/lib\/yui\/gallery\/","comboBase":"https:\/\/aulaglobal.uc3m.es\/theme\/yui_combo.php?","combine":true,"filter":"","ext":false,"root":"gallery\/","patterns":{"gallery-":{"group":"gallery","configFn":galleryConfigFn}}},"yui2":{"base":"https:\/\/aulaglobal.uc3m.es\/lib\/yuilib\/2in3\/2.9.0\/build\/","comboBase":"https:\/\/aulaglobal.uc3m.es\/theme\/yui_combo.php?","combine":true,"ext":false,"root":"2in3\/2.9.0\/build\/","patterns":{"yui2-":{"group":"yui2","configFn":yui2in3ConfigFn}}}}};
M.yui.loader = {modules: {}};
M.cfg = {"wwwroot":"https:\/\/aulaglobal.uc3m.es","sesskey":"WaluPhxWVX","loadingicon":"https:\/\/aulaglobal.uc3m.es\/theme\/image.php\/fusionuc3m\/core\/1412771764\/i\/loading_small","themerev":"1412771764","slasharguments":1,"theme":"fusionuc3m","jsrev":"1412771762","svgicons":true};
//]]>
</script>
<script type="text/javascript" src="./Assignment_files/javascript-static.js"></script>
<script type="text/javascript" src="./Assignment_files/head"></script>
<style type="text/css"></style><style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>
<body id="page-mod-wiki-prettyview" class="format-topics  path-mod path-mod-wiki safari dir-ltr lang-en yui-skin-sam yui3-skin-sam aulaglobal-uc3m-es pagelayout-embedded course-24014 context-998155 cmid-637402 category-831 jsenabled">
<div class="skiplinks"><a class="skip" href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#maincontent">Skip to main content</a></div>
<script type="text/javascript">
//<![CDATA[
document.body.className += ' jsenabled';
//]]>
</script>


<div id="page">

<!-- END OF HEADER -->

    <div id="content" class="clearfix">
        <div role="main"><span id="maincontent"></span><h1 id="wiki_printable_title">Enunciado</h1><div id="wiki_printable_content"><h1><a></a>Mandatory assignment</h1>
<h2><a></a>Introduction</h2>
<p>This statement describes a protocol between a client and a server as well as the behavior of the server upon reception of messages. You will need to have all the details into account to implement it.</p>
<p>You will need to implement the server, not the client (we provide a graphical client to test your server at any time). We provide also a compiled server so you can play with both of them to find out how it works.</p>
<p>The server can be implemented in preferred language, however, we provide some sample server implementations using C and Java that are the most common candidate languages. </p>
<h2><a></a>Help</h2>
<p><strong>Concurrency</strong></p>
<p>The server to be implemented should support several simultaneous connections. There are several strategies to accomplish this. Have a look to some examples:
</p><ol><li>Client to test the servers (written in C) <a href="http://www.it.uc3m.es/dds/aptel/en/client_c_en.html">Client C</a></li>
<li>Processes based concurrent server written in C <a href="http://www.it.uc3m.es/dds/aptel/en/server_c_processes_en.html">Server C processes</a></li>
<li>Thread based concurrent server written in C  <a href="http://www.it.uc3m.es/dds/aptel/en/server_c_threads_en.html">Server C threads</a></li>
<li>Select based concurrent server written in C <a href="http://www.it.uc3m.es/dds/aptel/en/server_c_select_en.html">Server C select</a></li>
<li>Select based concurrent server written in JAVA <a href="http://www.it.uc3m.es/dds/aptel/en/server_java_select_en.html">Server Java select</a></li>
</ol><p>If you want to use Java, I recommend you Eclipse. You can download it from <a href="https://www.eclipse.org/downloads/?osType=linux&release=undefined">here</a>. Select Linux/windows accordingly and make sure you have a JDK installed (no sure, download it from <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">here</a> either Java 7 or Java 8 would make the trick).</p>
<p>Do you need some hints to start using eclipse? Have a look <a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-3.htm">here</a></p>
<p><strong>Managing files and data structures (Under construction)</strong></p>
<p>This section provides you information about solving some file I/O problems and how to manage data structures as lists, arrays... We hope this will help you to solve some problems not related with the protocol so you can concentrate on the important part, the protocol. 
</p><ol><li>Create a file and allocate space (fill it with nothing) (Java, C)</li>
<li>Create directories (Java,C)</li>
<li>Determine the full path given a relative path and a base path (Java,C)</li>
<li>Write to a file given a start position and a length (Java,C)</li>
</ol><h2><a></a>Messages</h2>
<p>This section contains a detailed description of the messages of the protocol. Every message should have the header we describe below these lines and a payload that would change depending on the command:</p>
<h3><a></a>Common header for requests and responses</h3>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> ProtocolTag </th>
<th class="header c2" scope="col"> Length</th>
<th class="header c3" scope="col"> cmd</th>
<th class="header c4" scope="col"> MsgId</th>
<th class="header c5 lastcol" scope="col"> Payload</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1">2 Bytes</td>
<td class="cell c2">4 Bytes</td>
<td class="cell c3">1 Byte</td>
<td class="cell c4">4 Bytes</td>
<td class="cell c5 lastcol"> Var (defined by command)</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1">0x0111</td>
<td class="cell c2">5 to 65535</td>
<td class="cell c3">Cmd specific</td>
<td class="cell c4">Random</td>
<td class="cell c5 lastcol">Cmd specific (max 65530)</td>
</tr></tbody></table><ul><li>ProtocolTag: Have always the same value 0x0111, so, two bytes, the first one with value 0x01, the second with value 0x11. It allows to determine the start of a message within a buffer.</li>
<li>Length: Contains the length of the message without considering the ProtocolTag and the length field itself. Due to that, it will contain the bytes corresponding to CMD, MsgId and the Payload (1+4+ Payload length)</li>
<li>cmd: Identifies the command or the response. The codes can be any of the folowing:
<ul><li>Commands (Client -&gt; Server)
<ul><li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">LOGIN</a> (0x01)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">EXIT</a> (0x02)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">GET_STORAGE_DATA</a> (0x03)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">GET_FILES_IDS</a> (0x04)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">GET_FILE_CHUNKS</a> (0x05)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">ALLOCATE_FILE</a> (0x06)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">WRITE_FILE_CHUNK</a> (0x07)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">READ_FILE_CHUNK</a> (0x08)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">DELETE_FILE</a> (0x09)</li>
</ul></li>
<li>Respuestas (Server-&gt;Client)
<ul><li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">LOGIN_RESPONSE</a> (0x11)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">EXIT_RESPONSE</a> (0x12)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">GET_STORAGE_DATA_RESPONSE</a> (0x13)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">GET_FILES_IDS_RESPONSE</a> (0x14)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">GET_FILE_CHUNKS_RESPONSE</a> (0x15)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">ALLOCATE_FILE_RESPONSE</a> (0x16)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">WRITE_FILE_CHUNK_RESPONSE</a> (0x17)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">READ_FILE_CHUNK_RESPONSE</a> (0x18)</li>
<li><a href="https://aulaglobal.uc3m.es/mod/wiki/prettyview.php?pageid=950#">DELETE_FILE_RESPONSE</a> (0x19)</li>
</ul></li>
</ul></li>
<li>MsgId: 4 Bytes long random number chosen by the client. The server should use the same id for the answer to the message. </li>
<li>Payload: command specific</li>
</ul><h3><a></a>LOGIN</h3>
<p>Allows the user to identify to the system</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> username length </th>
<th class="header c2" scope="col"> username value</th>
<th class="header c3" scope="col"> password length</th>
<th class="header c4 lastcol" scope="col"> password value</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1">1 Byte</td>
<td class="cell c2">variable</td>
<td class="cell c3">1 Byte</td>
<td class="cell c4 lastcol">variable</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> variable</td>
<td class="cell c3">no</td>
<td class="cell c4 lastcol">variable</td>
</tr></tbody></table><ul><li>username length: In this version will always be 4</li>
<li>username value: The user name will be any number between 1001 y 9999</li>
<li>password length: In this version will always be 4</li>
<li>password value: The password should have the same value as the username</li>
</ul><p><strong>Server behavior</strong></p>
<p>Upon reception, the server should check the username and the password (in this version for APTEL students checking the username has the same value of the password and both are among 1001 and 9999 will be enough). The server should answer with a LOGIN_RESPONSE message.  If a LOGIN message is received after a previous one, the server will behave as if it is the first one (there is no user session, so the server should store no user session) even if it uses a different name. </p>
<h3><a></a>LOGIN_RESPONSE</h3>
<p>Indicates if the Login process was successful or not.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1 lastcol" scope="col"> success</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1 lastcol">1 Byte</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1 lastcol"> no</td>
</tr></tbody></table><ul><li>success: 0x01 for success or 0x00 otherwise</li>
</ul><p><strong>Server behavior</strong></p>
<p>The server sends this message only as a response to a LOGIN message. The message id (MsgId) should be the same as the message id of request that originated this response. </p>
<h3><a></a>EXIT</h3>
<p>El comando EXIT permite que el cliente salga del sistema.  </p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0 lastcol" scope="col"> Field Name</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0 lastcol">Field Length</td>
</tr><tr class="r1 lastrow"><td class="cell c0 lastcol">Default value</td>
</tr></tbody></table><p>No payload</p>
<p><strong>Server behavior</strong></p>
<p>Upon reception of EXTI, the server should send an EXIT_RESPONSE message and immediately after that will close the client socket. This should be done even no Login message was received.</p>
<h3><a></a>EXIT_RESPONSE</h3>
<p>Sent as a response to EXIT immediately before closing the socket.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0 lastcol" scope="col"> Field Name</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0 lastcol">Field Length</td>
</tr><tr class="r1 lastrow"><td class="cell c0 lastcol">Default value</td>
</tr></tbody></table><p>No payload</p>
<p><strong>Server behavior</strong></p>
<p>The server sends this message only as a response to a EXIT message. The message id (MsgId) should be the same as the message id of request that originated this response. </p>
<h3><a></a>GET_STORAGE_DATA</h3>
<p>Allows the client to know the size of the available space, how much is free/used.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0 lastcol" scope="col"> Field Name</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0 lastcol">Field Length</td>
</tr><tr class="r1 lastrow"><td class="cell c0 lastcol">Default value</td>
</tr></tbody></table><p>No payload</p>
<p><strong>Server behavior</strong></p>
<p>Upon reception the server answers with a GET_STORAGE_DATA_RESPONSE message.</p>
<h3><a></a>GET_STORAGE_DATA_RESPONSE</h3>
<p>Response to GET_STORAGE_DATA. </p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> totalSpace</th>
<th class="header c2" scope="col"> freeSpace</th>
<th class="header c3 lastcol" scope="col"> usedSpace</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1">8 Byte</td>
<td class="cell c2">8 Byte</td>
<td class="cell c3 lastcol">8 Byte</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2">no</td>
<td class="cell c3 lastcol">no</td>
</tr></tbody></table><ul><li>totalSpace: total space</li>
<li>freeSpace: free space</li>
<li>usedSpace: used space (totalSpace=freeSpace+usedSpace)</li>
</ul><p><strong>Server behavior</strong></p>
<p>The server sends this message only as a response to a GET_STORAGE_DATA message. The message id (MsgId) should be the same as the message id of request that originated this response. </p>
<h3><a></a>GET_FILES_IDS</h3>
<p>El comando GET_FILES_IDS permite obtener un identificador por cada fichero guardado por el servidor y que se podrá usar más adelante para operar con un fichero concreto. </p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0 lastcol" scope="col"> Field Name</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0 lastcol">Field Length</td>
</tr><tr class="r1 lastrow"><td class="cell c0 lastcol">Default value</td>
</tr></tbody></table><p>Sin carga (sin payload)</p>
<p><strong>Server behavior</strong></p>
<p>Al recibir este mensaje, el servidor deberá responder con un mensaje GET_FILES_IDS_RESPONSE conteniendo los identificadores.</p>
<h3><a></a>GET_FILES_IDS_RESPONSE</h3>
<p>Respuesta a GET_FILES_IDS.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> totalLength</th>
<th class="header c2" scope="col"> numberOfFiles</th>
<th class="header c3 lastcol" scope="col"> a FILEDESCRIPTOR_STRUCT per file</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1">4 Byte</td>
<td class="cell c2">4 Byte</td>
<td class="cell c3 lastcol"> variable (one per file)</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> no</td>
<td class="cell c3 lastcol"> no</td>
</tr></tbody></table><ul><li>totalLength: longitud total de esta carga (payload) es redundante dado que ya se tiene esa información en la cabecera, pero facilita el control de errores </li>
<li>numberOfFiles: número de ficheros cuya información se envía</li>
<li>FILEDESCRIPTOR_STRUCT: estructura que contiene la información de cada fichero y que se describe a continuación:</li>
</ul><p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> fileId</th>
<th class="header c2" scope="col"> fileSize</th>
<th class="header c3" scope="col"> relativePathLength</th>
<th class="header c4 lastcol" scope="col"> relativePath</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1">4 Bytes</td>
<td class="cell c2">8 Bytes</td>
<td class="cell c3">2 Bytes</td>
<td class="cell c4 lastcol"> variable </td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> no</td>
<td class="cell c3"> no</td>
<td class="cell c4 lastcol"> no</td>
</tr></tbody></table><ul><li>fileId: identificador de fichero. El servidor lo asigna aleatoriamente tras recibir un mensaje ALLOCATE_FILE.</li>
<li>fileSize: tamaño del fichero (el tamaño que se reservó con ALLOCATE_FILE) esté o no completo.</li>
<li>relativePathLength: longitud de la ruta relativa al fichero dentro del servidor.</li>
<li>relativePath: ruta relativa al fichero dentro del servidor en ASCII. Es la ruta elegida por el cliente (relativa al directorio del servidor y no absoluta) que se especificó con el mensaje ALLOCATE_FILE. El separador de directorios es '/'.</li>
</ul><p><strong>Server behavior</strong></p>
<p>Debe tener el mismo identificador de mensaje (MsgId) que tenía el mensaje GET_FILES_IDS recibido.</p>
<h3><a></a>GET_FILE_CHUNKS</h3>
<p>El fichero alojado con ALLOCATE_FILE está vacío. Más adelante, usando WRITE_FILE_CHUNK, se puede enviar un trozo del fichero para que el servidor lo guarde. Trozo a trozo, el fichero puede completarse. El comando GET_FILE_CHUNKS permite conocer cuantos trozos del fichero están disponibles en el servidor.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1 lastcol" scope="col"> fileId</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1 lastcol">4 Byte</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1 lastcol"> no</td>
</tr></tbody></table><ul><li>fileId: Debe contener un identificador de fichero válido obtenido previamente con GET_FILE_IDS.</li>
</ul><p><strong>Server behavior</strong></p>
<p>Al recibir este mensaje, el servidor comprueba si el identificador de fichero es válido o no y contesta con GET_FILE_CHUNK_RESPONSE.</p>
<h3><a></a>GET_FILE_CHUNKS_RESPONSE</h3>
<p>Es la respuesta al mensaje GET_FILE_CHUNK.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> success</th>
<th class="header c2" scope="col"> fileId</th>
<th class="header c3" scope="col"> totalLength</th>
<th class="header c4" scope="col"> numberOfChunks</th>
<th class="header c5 lastcol" scope="col"> a CHUNK_DESCRIPTOR per chunk</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1">1 Byte</td>
<td class="cell c2">4 Bytes</td>
<td class="cell c3">4 Bytes</td>
<td class="cell c4">4 Bytes</td>
<td class="cell c5 lastcol"> length of CHUNK_DESCRIPTOR * numberOfChunks</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> no</td>
<td class="cell c3"> no</td>
<td class="cell c4"> no</td>
<td class="cell c5 lastcol"> no</td>
</tr></tbody></table><ul><li>success: 0x01 for success or 0x00 otherwise</li>
<li>fileId: el identificador de fichero al que corresponde la información</li>
<li>totalLength: longitud total a partir de este punto contando numberOfChunks (4+ longitud de CHUNK_DESCRIPTOR*numberOfChunks)</li>
<li>numberOfChunks: numero de chunks</li>
<li>CHUNK_DESCRIPTOR: habrá una estructura de estas por chunk. Si no hay ningún chunk disponible (fichero creado pero vacío) no se manda esta parte. Su descripción es la siguiente:</li>
</ul><p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> start</th>
<th class="header c2" scope="col"> end</th>
<th class="header c3 lastcol" scope="col"> length</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1">8 Byte</td>
<td class="cell c2">8 Bytes</td>
<td class="cell c3 lastcol">8 Bytes</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> no</td>
<td class="cell c3 lastcol"> no</td>
</tr></tbody></table><ul><li>start: primer byte del fichero al que corresponde el chunk o trozo</li>
<li>end: ultimo byte del fichero al que corresponde el chunk</li>
<li>length: longitud del chunk</li>
</ul><p><strong>Server behavior</strong></p>
<p>The server sends this message only as a response to a GET_FILE_CHUNK message. The message id (MsgId) should be the same as the message id of request that originated this response. </p>
<h3><a></a>ALLOCATE_FILE</h3>
<p>Este mensaje permite indicar la ruta relativa y nombre de un fichero a crear, indicar su tamaño, crear el fichero en el servidor, rellenarlo (vacío) y reservar el espacio.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> relativePathLength </th>
<th class="header c2" scope="col"> relativePath</th>
<th class="header c3 lastcol" scope="col"> fileSize</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1">2 Bytes</td>
<td class="cell c2">variable</td>
<td class="cell c3 lastcol">8 Bytes</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> no</td>
<td class="cell c3 lastcol">no</td>
</tr></tbody></table><ul><li>relativePathLength: longitud del path relativo</li>
<li>relativePath: path relativo. Sea el que sea la carpeta usada por el servidor para guardar los ficheros, este path indica las carpetas y nombre de fichero dentro de la carpeta del servidor donde debe crearse. El separador de directorios es '/'. Ejemplo: '/dir-12/otrodir-3/mifichero.pdf'</li>
<li>fileSize: tamaño del fichero</li>
</ul><p><strong>Server behavior</strong></p>
<p>Tras recibir este mensaje, debe comprobar: que el path es correcto (se puede crear el fichero); que hay espacio para crearlo. Si es posible crearlo y hay espacio, debe crear el fichero, rellenarlo (con cualquier cosa) para que ocupe el tamaño deseado y actualizar los valores de espacio usado y disponible. Debe crear un identificador aleatorio de 4 bytes para el fichero y almacenarlo junto con la ruta para futuras referencias. Responderá con ALLOCATE_FILE_RESPONSE indicando éxito o no.</p>
<h3><a></a>ALLOCATE_FILE_RESPONSE</h3>
<p>Respuesta del servidor a ALLOCATE_FILE</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> success</th>
<th class="header c2 lastcol" scope="col"> fileId</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1">1 Byte</td>
<td class="cell c2 lastcol"> 4 Bytes</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2 lastcol"> no</td>
</tr></tbody></table><ul><li>success: 0x01 for success or 0x00 otherwise</li>
<li>fileId: identificador aleatorio generado por el servidor para este fichero.</li>
</ul><p><strong>Server behavior</strong></p>
<p>The server sends this message only as a response to a ALLOCATE_FILE message. The message id (MsgId) should be the same as the message id of request that originated this response. </p>
<h3><a></a>READ_FILE_CHUNK</h3>
<p>El comando READ_FILE_CHUNK permite leer un trozo de un fichero disponible en el servidor. </p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> fileId</th>
<th class="header c2" scope="col"> start</th>
<th class="header c3" scope="col"> end</th>
<th class="header c4 lastcol" scope="col"> length</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1"> 4 Bytes</td>
<td class="cell c2"> 8 Bytes</td>
<td class="cell c3"> 8 Bytes</td>
<td class="cell c4 lastcol"> 8 Bytes</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> no</td>
<td class="cell c3"> no</td>
<td class="cell c4 lastcol"> no</td>
</tr></tbody></table><p><strong>Server behavior</strong></p>
<p>Al recibir el mensaje el servidor debe comprobar: si existe un fichero con ese identificador, si el trozo solicitado (en función de start, end y length) está disponible en el servidor (ha tenido que ser escrito antes). Si existe, lee el trozo del fichero desde la posición start a la posición end y devuelve una respuesta READ_FILE_CHUNK_RESPONSE indicando éxito o no y con la información solicitada.</p>
<h3><a></a>READ_FILE_CHUNK_RESPONSE</h3>
<p>Es la respuesta al mensaje READ_FILE_CHUNK.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> success</th>
<th class="header c2" scope="col"> fileId</th>
<th class="header c3" scope="col"> start</th>
<th class="header c4" scope="col"> end</th>
<th class="header c5" scope="col"> length</th>
<th class="header c6 lastcol" scope="col"> data</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1"> 1 Bytes</td>
<td class="cell c2"> 4 Bytes</td>
<td class="cell c3"> 8 Bytes</td>
<td class="cell c4"> 8 Bytes</td>
<td class="cell c5"> 8 Bytes</td>
<td class="cell c6 lastcol"> variable</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> no</td>
<td class="cell c3"> no</td>
<td class="cell c4"> no</td>
<td class="cell c5"> no</td>
<td class="cell c6 lastcol"> no</td>
</tr></tbody></table><ul><li>success: 0x01 for success or 0x00 otherwise</li>
<li>fileId: identificador del fichero al que pertenece este trozo</li>
<li>start: primer byte del fichero al que corresponde el chunk o trozo</li>
<li>end: ultimo byte del fichero al que corresponde el chunk o trozo</li>
<li>length: longitud de chunk o trozo</li>
<li>data: datos leidos del fichero (sólo se incluyen si success = 0x01)</li>
</ul><p><strong>Server behavior</strong></p>
<p>The server sends this message only as a response to a READ_FILE_CHUNK message. The message id (MsgId) should be the same as the message id of request that originated this response. </p>
<h3><a></a>WRITE_FILE_CHUNK</h3>
<p>Este mensaje permite escribir un trozo en el fichero.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> fileId</th>
<th class="header c2" scope="col"> start</th>
<th class="header c3" scope="col"> end</th>
<th class="header c4" scope="col"> length</th>
<th class="header c5 lastcol" scope="col"> data</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1"> 4 Bytes</td>
<td class="cell c2"> 8 Bytes</td>
<td class="cell c3"> 8 Bytes</td>
<td class="cell c4"> 8 Bytes</td>
<td class="cell c5 lastcol"> variable</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> no</td>
<td class="cell c3"> no</td>
<td class="cell c4"> no</td>
<td class="cell c5 lastcol"> no</td>
</tr></tbody></table><ul><li>fileId: identificador del fichero sobre el que se pretende escribir (en algún momento se creó con ALLOCATE_FILE)</li>
<li>start: primer byte del fichero al que corresponde el chunk o trozo</li>
<li>end: ultimo byte del fichero al que corresponde el chunk o trozo</li>
<li>length: longitud de chunk o trozo</li>
<li>data: datos a escribir en el fichero </li>
</ul><p><strong>Server behavior</strong></p>
<p>Tras recibir este mensaje, el servidor debe comprobar si existe un fichero con ese identificador, si el trozo que pretende escribir no ha sido escrito anteriormente (aunque sea parcialmente). Si todo es correcto, escribe el trozo (data) en el fichero comenzando por la posición start y finalizando en end. data debe tener la longitud correcta. Devuelve una respuesta WRITE_FILE_CHUNK_RESPONSE indicando éxito o no.</p>
<h3><a></a>WRITE_FILE_CHUNK_RESPONSE</h3>
<p>Es la respuesta al mensaje WRITE_FILE_CHUNK.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> success</th>
<th class="header c2" scope="col"> fileId</th>
<th class="header c3" scope="col"> start</th>
<th class="header c4" scope="col"> end</th>
<th class="header c5 lastcol" scope="col"> length</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1"> 1 Bytes</td>
<td class="cell c2"> 4 Bytes</td>
<td class="cell c3"> 8 Bytes</td>
<td class="cell c4"> 8 Bytes</td>
<td class="cell c5 lastcol"> 8 Bytes</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2"> no</td>
<td class="cell c3"> no</td>
<td class="cell c4"> no</td>
<td class="cell c5 lastcol"> no</td>
</tr></tbody></table><ul><li>success: 0x01 for success or 0x00 otherwise</li>
<li>fileId: identificador del fichero al que pertenece el trozo escrito</li>
<li>start: primer byte del fichero al que corresponde el chunk o trozo</li>
<li>end: ultimo byte del fichero al que corresponde el chunk o trozo</li>
<li>length: longitud de chunk o trozo</li>
</ul><p><strong>Server behavior</strong></p>
<p>The server sends this message only as a response to a WRITE_FILE_CHUNK message. The message id (MsgId) should be the same as the message id of request that originated this response.</p>
<h3><a></a>DELETE_FILE</h3>
<p>Permite borrar un fichero</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1 lastcol" scope="col"> fileId</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1 lastcol"> 4 Bytes</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1 lastcol"> no</td>
</tr></tbody></table><ul><li>fileId: identificador del fichero que se desea borrar</li>
</ul><p><strong>Server behavior</strong></p>
<p>Al recibir el mensaje, debe comprobarse que el fichero existe. De ser así, se borra. Se devuelve un mensaje DELETE_FILE_RESPONSE indicando exito (borrado) o no.</p>
<h3><a></a>DELETE_FILE_RESPONSE</h3>
<p>Es la respuesta al mensaje DELETE_FILE.</p>
<p><strong>Payload format</strong></p>
<p></p><table class="generaltable"><thead><tr><th class="header c0" scope="col"> Field Name</th>
<th class="header c1" scope="col"> success</th>
<th class="header c2 lastcol" scope="col"> fileId</th>
</tr></thead><tbody><tr class="r0"><td class="cell c0">Field Length</td>
<td class="cell c1"> 1 Bytes</td>
<td class="cell c2 lastcol"> 4 Bytes</td>
</tr><tr class="r1 lastrow"><td class="cell c0">Default value</td>
<td class="cell c1"> no</td>
<td class="cell c2 lastcol"> no</td>
</tr></tbody></table><ul><li>success: 0x01 for success or 0x00 otherwise</li>
<li>fileId: identificador del fichero borrado (exito) o que no se pudo borrar.</li>
</ul><p><strong>Server behavior</strong></p>
<p>The server sends this message only as a response to a DELETE_FILE message. The message id (MsgId) should be the same as the message id of request that originated this response.</p>
</div></div>    </div>

<!-- START OF FOOTER -->
</div>
<script type="text/javascript" src="./Assignment_files/footer"></script>
<script type="text/javascript">
//<![CDATA[
M.str = {"moodle":{"lastmodified":"Last modified","name":"Name","error":"Error","info":"Information","cancel":"Cancel","yes":"Yes"},"repository":{"type":"Type","size":"Size","invalidjson":"Invalid JSON string","nofilesattached":"No files attached","filepicker":"File picker","logout":"Logout","nofilesavailable":"No files available","norepositoriesavailable":"Sorry, none of your current repositories can return files in the required format.","fileexistsdialogheader":"File exists","fileexistsdialog_editor":"A file with that name has already been attached to the text you are editing.","fileexistsdialog_filemanager":"A file with that name has already been attached","renameto":"Rename to \"{$a}\"","referencesexist":"There are {$a} alias\/shortcut files that use this file as their source"},"block":{"addtodock":"Move this to the dock","undockitem":"Undock this item","undockall":"Undock all","hidedockpanel":"Hide the dock panel","hidepanel":"Hide panel"},"langconfig":{"thisdirectionvertical":"btt"},"admin":{"confirmation":"Confirmation"}};
//]]>
</script>
<script type="text/javascript">
//<![CDATA[
YUI().use('node', function(Y) {
M.util.load_flowplayer();
setTimeout("fix_column_widths()", 20);
M.util.help_popups.setup(Y);

});
//]]>
</script>

<div id="naptha_container0932014_0707" style="position: absolute; top: 0px; left: 0px;"></div></body></html>